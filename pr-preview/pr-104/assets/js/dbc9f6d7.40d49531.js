"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[74],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(r),f=o,h=p["".concat(s,".").concat(f)]||p[f]||d[f]||a;return r?n.createElement(h,i(i({ref:t},u),{},{components:r})):n.createElement(h,i({ref:t},u))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},4333:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=r(7462),o=(r(7294),r(3905));const a={sidebar_position:2,sidebar_label:"Rollkit Transaction Flow",description:"Description of a rollkit transaction flow."},i="Transaction Flow",l={unversionedId:"transaction-flow",id:"transaction-flow",title:"Transaction Flow",description:"Description of a rollkit transaction flow.",source:"@site/docs/transaction-flow.md",sourceDirName:".",slug:"/transaction-flow",permalink:"/pr-preview/pr-104/docs/transaction-flow",draft:!1,editUrl:"https://github.com/rollkit/docs/tree/main/docs/transaction-flow.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Rollkit Transaction Flow",description:"Description of a rollkit transaction flow."},sidebar:"tutorialSidebar",previous:{title:"Rollkit Stack",permalink:"/pr-preview/pr-104/docs/rollkit-stack"},next:{title:"Tutorials",permalink:"/pr-preview/pr-104/docs/category/tutorials"}},s={},c=[],u={toc:c};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"transaction-flow"},"Transaction Flow"),(0,o.kt)("p",null,"Rollup users use a light node to communicate with the rollup p2p network for two primary reasons: to receive the current state of the rollup and to submit transactions. To transact, users submit a transaction to their running light node, which gossips the transaction to a full node. Before adding the transaction to their mempool, the full node checks its validity. Valid transactions are included in the mempool, while invalid ones are refused, and the user transaction will not be processed."),(0,o.kt)("p",null,"If the transaction is valid and has been included in the mempool, the sequencer can add it to a rollup block, which is then submitted to the data availability layer with a PFB(pay for blob). This results in a successful transaction flow for the user, and the state of the rollup is updated accordingly."),(0,o.kt)("p",null,"However, there is a possibility that the sequencer may alter the user's transaction and submit an invalid block to the DA layer, either by mistake or maliciously. In such cases, the full nodes of the rollup chain will consider the block as invalid. After the block is submitted to the DA layer, the full nodes will download and validate it. If they find the block invalid, they generate fraud proofs and gossip them in the p2p network among other full nodes and light clients."),(0,o.kt)("p",null,"As a result, the rollup chain will halt, and the network will decide to fork the chain through social consensus. In the future, when a decentralized sequencer scheme is in place, additional options will be available, such as slashing the sequencer or selecting another full node as the sequencer. However, in any case, a new block must be created and submitted to the DA layer."))}p.isMDXComponent=!0}}]);