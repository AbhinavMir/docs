"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[56],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),u=o,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||i;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9333:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:5,sidebar_label:"Specs"},r="Specifications of the Rollkit Scheme and Necessary Components",l={unversionedId:"specs",id:"specs",title:"Specifications of the Rollkit Scheme and Necessary Components",description:"Components",source:"@site/docs/specs.md",sourceDirName:".",slug:"/specs",permalink:"/docs/specs",draft:!1,editUrl:"https://github.com/rollkit/docs/tree/main/docs/specs.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,sidebar_label:"Specs"},sidebar:"tutorialSidebar",previous:{title:"Recipe Book Rollup Tutorial",permalink:"/docs/tutorials/recipe-book"}},s={},d=[{value:"Components",id:"components",level:2},{value:"ABCI Client",id:"abci-client",level:3},{value:"Mempool",id:"mempool",level:3},{value:"Interface Overview",id:"interface-overview",level:4},{value:"Data Types and Message Formats",id:"data-types-and-message-formats",level:3},{value:"Block.Data",id:"blockdata",level:4},{value:"Fraud Proofs",id:"fraud-proofs",level:4},{value:"Implement interface with",id:"implement-interface-with",level:4},{value:"Transacation Lifecycle",id:"transacation-lifecycle",level:2},{value:"Transaction Aggregation",id:"transaction-aggregation",level:3},{value:"ABCI Interface",id:"abci-interface",level:3},{value:"P2P Layer",id:"p2p-layer",level:4},{value:"Peer discovery",id:"peer-discovery",level:5},{value:"Transactions and Fraud Proof Gossiping",id:"transactions-and-fraud-proof-gossiping",level:5},{value:"Commits to DA and Consensus Layer",id:"commits-to-da-and-consensus-layer",level:3},{value:"Cosmos-SDK Rollkit Module",id:"cosmos-sdk-rollkit-module",level:3},{value:"Sparse Merkle Trees",id:"sparse-merkle-trees",level:4},{value:"Intermediate State Roots",id:"intermediate-state-roots",level:4},{value:"Customizing Modules",id:"customizing-modules",level:2}],c={toc:d};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"specifications-of-the-rollkit-scheme-and-necessary-components"},"Specifications of the Rollkit Scheme and Necessary Components"),(0,o.kt)("h2",{id:"components"},"Components"),(0,o.kt)("p",null,"Components and their corresponding message types, depend on the interface\ni.e. mempool, etc."),(0,o.kt)("h3",{id:"abci-client"},"ABCI Client"),(0,o.kt)("p",null,"This document provides an overview how these chains can be built using Celestia\nas a Data Availability (DA) and Co on how to implement Cosmos-SDK based Rollup\nchains. It goes into detail aboutnsensus Layer. At the same time we try to\nkeep the high level API general enough such that developers can choose\nalternative DA and Consensus Layers (e.g. Ethereum, the Cosmos Hub)."),(0,o.kt)("p",null,"We briefly compare building a Cosmos-SDK Rollmint chain with the status quo\n(building a sovereign Cosmos zone): The current way to use the Cosmos-SDK is to\ndefine the state-machine, also referred to as the Application. Application\ndevelopers do not have to bother about the lower Layers, namely consensus and\nnetworking. The lower Layers are currently handled by another\napplication-agnostic piece of the stack, namely the ABCI Client which defaults\nto ",(0,o.kt)("inlineCode",{parentName:"p"},"tendermint-core"),". We will replace the default ABCI Client with one that\ndoes not handle Consensus itself. Instead it will only provide the networking\nLayers, and will use the Consensus of the DA Layer. How exactly will be\ndescribed below:"),(0,o.kt)("p",null,"To summarize, if a current SDK-based app roughly follows the following\narchitecture:"),(0,o.kt)("p",null,"[",(0,o.kt)("strong",{parentName:"p"},"diagram_1"),"]"),(0,o.kt)("p",null,"When implementing a Cosmos-SDK based Rollmint chain, this overview changes to:"),(0,o.kt)("p",null,"[",(0,o.kt)("strong",{parentName:"p"},"diagram_2"),"]"),(0,o.kt)("p",null,"Note that from the point of view of an application developer, nothing changes.\nRollmint has the exact same developer experience as the usual Cosmos-SDK with\nTendermint provides: they still just have to define their business /\nstate-machine logic. The Rollmint-specific ABCI Client is stripped down to only\nhandle the network Layer but it also embeds a light node of the DA and\nConsensus Layer chain used and takes care of submitting the block to the DA\nand Consensus Layer. This can also be done with a Consensus Full Node."),(0,o.kt)("p",null,"As with Tendermint the state-machine and Rollmint interact with each other via\nABCI."),(0,o.kt)("h3",{id:"mempool"},"Mempool"),(0,o.kt)("p",null,"The mempool keeps the set of pending transactions, and is used by block producers\n(full nodes) to produce blocks. Transactions are handled by nodes in the\nFirst-Come, First-Served (FCFS) manner. Ordering of transactions can be\nimplemented on the application level (for example by adding nonce/sequence\nnumber). This behaviour is similar to the Tendermint mempool."),(0,o.kt)("h4",{id:"interface-overview"},"Interface Overview"),(0,o.kt)("h3",{id:"data-types-and-message-formats"},"Data Types and Message Formats"),(0,o.kt)("h4",{id:"blockdata"},"Block.Data"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Field"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TXs")),(0,o.kt)("td",{parentName:"tr",align:null},"Transaction data")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"intermediateStateRoots")),(0,o.kt)("td",{parentName:"tr",align:null},"Intermediate state roots for each transaction")))),(0,o.kt)("h4",{id:"fraud-proofs"},"Fraud Proofs"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'While Rollkit allows you to build sovereign rollups on Celestia, it currently\ndoes not support fraud proofs yet and is therefore running in "pessimistic"\nmode, where nodes would need to re-execute the transactions to check the\nvalidity of the chain (i.e. a full node). Furthermore, Rollkit currently only\nsupports a single sequencer.')),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Field"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"blockHash")),(0,o.kt)("td",{parentName:"tr",align:null},"Hash of corresponding block header")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"preStateRoot")),(0,o.kt)("td",{parentName:"tr",align:null},"Root of Sparse Merkle Tree of the blockchain state before transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"postStateRoot")),(0,o.kt)("td",{parentName:"tr",align:null},"Root of Sparse Merkle Tree of the blockchain state after transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"transaction")),(0,o.kt)("td",{parentName:"tr",align:null},"Transaction (app specific)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"witness")),(0,o.kt)("td",{parentName:"tr",align:null},"Merkle Proofs")))),(0,o.kt)("h4",{id:"implement-interface-with"},"Implement interface with"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Narwahl",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Data types and Message Formats"))),(0,o.kt)("li",{parentName:"ul"},"Tusk",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Data types and Message Formats")))),(0,o.kt)("h2",{id:"transacation-lifecycle"},"Transacation Lifecycle"),(0,o.kt)("h3",{id:"transaction-aggregation"},"Transaction Aggregation"),(0,o.kt)("p",null,"Transactions will be aggregated by full nodes. It is fundamentally the same\noperation as creating a block with ABCI interface. Multiple parameters should be\nconfigurable e.g. block time, maximum block size."),(0,o.kt)("h3",{id:"abci-interface"},"ABCI Interface"),(0,o.kt)("p",null,"ABCI is what will enable a relatively seamless replacement of Tendermint with\nRollmint. Of course the devil is in the detail and there is more to it than\nsimply replacing Tendermint with another piece of software that fulfils the\nclient side of the ABCI contract, e.g. the SDK spins up a Tendermint node. These\nplaces seem managable and having a clear interface between state-machine and the\nDA and Consensus Layer makes it possible to replace Tendermint with another\nABCI Client."),(0,o.kt)("p",null,"As we want to change as little as possible inside the SDK we will surely have to\nstick to the vanilla ABCI interface. That said, some of the properties we also\nwant for the Rollmint chains, e.g., that the intermediate state roots and the\nfinal state root (e.g. app-hash) of a block match the state transitions implied\nby the Transactions included in that very same block require changes in the ABCI\nitself. While ABCI++ is not part of this project\u2019s scope, we are\nclosely monitoring ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tendermint/spec/pull/254"},"ABCI++")," and\nplan to closely collaborate with Sikka on both specifying as well as\nfacilitating the implementation efforts by providing feedback or by implementing\nthe parts that we need in our forks."),(0,o.kt)("h4",{id:"p2p-layer"},"P2P Layer"),(0,o.kt)("p",null,"Full nodes and light nodes will be connected by the peer-to-peer network\nimplemented with Libp2p. There are many implementations of Publish-Subscribe\nmessaging pattern, but ",(0,o.kt)("inlineCode",{parentName:"p"},"libp2p-gossipsub")," is chosen because it\u2019s the most advanced\none."),(0,o.kt)("h5",{id:"peer-discovery"},"Peer discovery"),(0,o.kt)("p",null,"Initial peer discovery will be done via static configuration. Those\nbootstrap/seed nodes will then be used by ",(0,o.kt)("inlineCode",{parentName:"p"},"go-libp2p-discovery")," to connect to\nthe rest of the network and maintain a peer list."),(0,o.kt)("h5",{id:"transactions-and-fraud-proof-gossiping"},"Transactions and Fraud Proof Gossiping"),(0,o.kt)("p",null,"Transactions will be propagated in the P2P network using the gossiping mechanism."),(0,o.kt)("p",null,"Fraud proofs can be produced only by full nodes. They will be delivered to all\nnodes in the network with a gossiping mechanism. This will ensure that fraud\nproofs are delivered to all nodes as soon as possible, without delay (like\nwaiting on block finalization). If the grace period is shorter than block time,\nlight nodes don\u2019t need to keep historical data."),(0,o.kt)("h3",{id:"commits-to-da-and-consensus-layer"},"Commits to DA and Consensus Layer"),(0,o.kt)("p",null,"Rollkit needs to submit the block to the DA and Consensus Layer. For that it\nneeds to keep a light node of the DA and Consensus chain running. Additionally,\nit will need an account of that chain and sufficient balances for submitting a\nTransaction to the DA and Consensus chain."),(0,o.kt)("p",null,"Note that this only triggers a real state transition on the DA and Consensus\nchain. On the Rollkit chain successfully submitting the block to the DA and\nConseneus Layer (which includes it in its block) means that the Rollkit block\nwas finalized."),(0,o.kt)("p",null,"To keep the greatest flexibility, we start with the following very limited\ninterface and extend it only if necessary for implementing using Celestia as a\nDA and Consensus Layer (certainly in a way that would not limit developers to\nuse other DA and Consensus Layers though):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// TODO define an enum of different non-happy-path cases\n// that might need to be handled by Rollkit independent of\n// the underlying DA and Consensus chain.\ntype StatusCode uint64\n\ntype ResultSubmitBlock struct {\n  // Code is to determine if the action succeeded.\n  Code StatusCode\n  // Not sure if this needs to be bubbled up to other\n  // parts of Rollkit.\n  // Hash hash.Hash\n}\n\ntype DataAvailabilityLayerClient interface {\n  Start() error\n  Stop() error\n\n  // SubmitBlock submits the passed in block to the DA and Consensus Layer\n  // This should create a transaction which (potentially)\n  // triggers a state transition in the DA and Consensus Layer\n  SubmitBlock(block types.Block) ResultSubmitBlock\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SubmitBlock")," method will be called on an aggregator node before Rollkit tells\nthe application (via ABCI) to commit the state via the Commit method\n",(0,o.kt)("inlineCode",{parentName:"p"},"FinalizeBlock"),". Only if ",(0,o.kt)("inlineCode",{parentName:"p"},"SubmitBlock")," succeeds the application will update the\nstate accordingly, otherwise the aggregator has to retry or another aggregator\nnode might do so before the aggregator does (in that case we need a tie breaking\nrule, e.g. first-come-first-serve is a good start here, or, round-robin which\nwould be more similar to using Tendermint). ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Stop")," are only called\ntogether with spinning up or shutting down the node respectively."),(0,o.kt)("h3",{id:"cosmos-sdk-rollkit-module"},"Cosmos-SDK Rollkit Module"),(0,o.kt)("h4",{id:"sparse-merkle-trees"},"Sparse Merkle Trees"),(0,o.kt)("p",null,"The state of the Rollmint chain will be stored in a Sparse Merkle Tree. They can\nbe used to generate fraud proofs in very compact and easy to verify form."),(0,o.kt)("p",null,"Celestia Labs and the Rollkit team actively participated in developing a\n",(0,o.kt)("inlineCode",{parentName:"p"},"proSeparation")," of storage and commitment (by the SMT) allows the optimization\nof different components according to their usage and access patterns."),(0,o.kt)("p",null,"Proposal for replacing IAVL+ trees with SMTs for the entire state in Cosmos-SDK."),(0,o.kt)("h4",{id:"intermediate-state-roots"},"Intermediate State Roots"),(0,o.kt)("p",null,"To be able to validate fraud proofs, blocks of the Rollmint chain have to\ncontain intermediate state roots, reflecting the state of SMT after every transaction."),(0,o.kt)("h2",{id:"customizing-modules"},"Customizing Modules"),(0,o.kt)("p",null,"soon\u1d40\u1d39"))}p.isMDXComponent=!0}}]);